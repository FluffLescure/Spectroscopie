\documentclass[11pt, openright]{book}

	% Cover Variables
		\newcommand{\ctoptitle}{}
        \newcommand{\ctitle}{SYNTHÈSE TP AT33}
        \newcommand{\cautor}{Eva Maturana - Lucas Lescure}

	% Header Variables
        \newcommand{\headLE}{\emph{\thepage}}
        \newcommand{\headRE}{\emph{\thesection. \rightmark}}
        \newcommand{\footRE}{}
        \newcommand{\footLE}{}

	% TOC Variables
        \newcommand{\toctitle}{Table des Contenus}
        \newcommand{\tocchapter}{Chapter}
        \newcommand{\toccount}{3}

	% Chapter Variables
        \newcommand{\chvar}{Chapter -}

\input{/root/.config/latex-utils/common/style.tex}
\input{/root/.config/latex-utils/common/math.tex}
\input{/root/.config/latex-utils/common/header.tex}
\input{/root/.config/latex-utils/common/toc.tex}

	% figure support
	\usepackage{import}
	\usepackage{xifthen}
	\pdfminorversion=7
	\usepackage{pdfpages}
	\usepackage{transparent}
	\newcommand{\incfig}[1]{%
		\def\svgwidth{\columnwidth}
        \import{./figures/}{#1.pdf_tex}
	}

\definecolor{clr-background}{RGB}{255,255,255}
\definecolor{clr-text}{RGB}{0,0,0}
\definecolor{clr-string}{RGB}{200,80,21}
\definecolor{clr-namespace}{RGB}{0,0,0}
\definecolor{clr-preprocessor}{RGB}{128,128,128}
\definecolor{clr-keyword}{RGB}{0,0,255}
\definecolor{clr-type}{RGB}{43,100,200}
\definecolor{clr-variable}{RGB}{0,0,0}
\definecolor{clr-constant}{RGB}{111,0,138} % macro color
\definecolor{clr-comment}{RGB}{0,128,0}

\lstset{
	language=C++,
	backgroundcolor=\color{clr-background},
	basicstyle=\color{clr-text}\scriptsize, % any text
	stringstyle=\color{clr-string},
	identifierstyle=\color{clr-variable}, % just about anything that isn't a directive, comment, string or known type
	commentstyle=\color{clr-comment},
	% listings doesn't differentiate between types and keywords (e.g. int vs return)
	% use the user types color
	keywordstyle=\color{clr-type},
	keywordstyle={[2]\color{clr-constant}}, % you'll need to define these or use a custom language
	tabsize=4
}
\pdfsuppresswarningpagegroup=1

\begin{document}
% Spacing
\input{/root/.config/latex-utils/common/begin.tex}

% Cover
\input{/root/.config/latex-utils/common/cover.tex}

\newpage

\section{Programmes de base}

\subsection{Manipulation des arguments en ligne de commande}

\subsubsection{Exercise 1}

On veut créer un programme qui accepte $3$ arguments en ligne de commande et les affiche. Dans le cas où il n'y a pas $3$ arguments on désire retourner le code d'erreur \texttt{EXIT\_FAILURE} ainsi qu'un message d'erreur.
\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>

int main (int argc, char* argv[]) {
	if(argc != 4){
		printf("\nerreur %s, il faut 3 arguments, vous en avez passe %d", arcgv[0], argc - 1);
		return EXIT_FAILURE;
	} else {
		for(int i = 0; i < 4; i++){
			printf("\nargv[%d] = %s", i, argv[i]);
		}
		return EXIT_SUCCESS;
	}
}
					\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}
Pour pouvoir manipuler des arguments en ligne commande, on définit la fonction \texttt{main()} en faisant passer les variables \texttt{argc}, qui compte le nombre d'arguments passés, et \texttt{argv[]} qui sauvegarde sous forme de \texttt{const char*} les arguments passés dans un tableau.

Pour afficher un message à l'utilisateur dans la console il faut utiliser la fonction \texttt{printf()} car la fonction \texttt{cout} n'existe que en \texttt{C++}.

Après avoir codé le programme on utilise le compilateur \texttt{gcc} avec \texttt{-o <fichier>.o } en argument pour créer un objet executable par l'utilisateur. Il ne suffit donc plus que d'exécuter ce dernier avec la command \texttt{./ex1.o}

En utilisant ceci on retrouve les exécutions suivantes: \\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex1.o il faut 3 arguments}\\
\texttt{erreur ./ex1.o, il faut 3 arguments, vous en avez passé 4}\\
\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex1.o faut 3 arguments}\\
\texttt{argv[0] = ./ex1.o}\\
\texttt{argv[1] = faut}\\
\texttt{argv[2] = 3}\\
\texttt{argv[3] = arguments}

\subsubsection{Exercise 2}

On veut créer un programme qui accepte $2$ arguments(entiers) en ligne de commande, retourne \texttt{EXIT\_FAILURE} dans le cas échéant, et affiche les deux entier ainsi que leur somme, leur produit et leur différence.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char* argv[]) {
    if(argc != 3) {
        printf("erreur %s, il faut 2 arguments", argv[0]);
        return EXIT_FAILURE;
    } else {
        int A = atoi(argv[1]); int B = atoi(argv[2]);

        printf("\nA = %d; B = %d", A, B);
        printf("\nA + B = %d", A + B);
        printf("\nA * B = %d", A * B);
        printf("\nA - B = %d", A - B);
    
        return EXIT_SUCCESS;
    }
}				\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

On construit le programme ci-dessous en utilisant les notions vues précédemment et cette fois-ci en faisant intervenir un nouvelle fonction \texttt{atoi()} dans la librairie \texttt{stdlib.h} permettant de retourner un \texttt{int} d'un \texttt{const char*} passé en paramètre.

En stockant la valeurs des arguments en ligne de commande dans les entiers \texttt{A} et \texttt{B} on peut alors traiter les deux entiers dans notre programme et y effectuer des opérations.
\newpage
Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex2.o 5 1245}\\
\texttt{A = 5; B = 1245}\\
\texttt{A + B = 1250}\\
\texttt{A * B = 6225}\\
\texttt{A - B = -1240}


\subsection{Pilotage de GPIO en sortie}

\subsubsection{Exercise 1}

On veut construire un programme qui permet de piloter le niveau logique du \texttt{GPIO19}, tel que l'argument passé en ligne de commande corresponde à l'état logique de la LED.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char* argv[]) {
    if(argc != 2) {
        printf("erreur %s, il faut 1 argument", argv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        char path_d[100]; char path_v[100];
        int val = atoi(argv[1]);
        
        sprintf(path_d, "/sys/class/gpio/gpio19/direction");
        sprintf(path_v, "/sys/class/gpio/gpio19/value");

        fichier = fopen(path_d, "w");
            fprintf(fichier, "out");
        fclose(fichier);

        fichier = fopen(path_v, "w");
            fprint(fichier, "%d", val);
        fclose(fichier);

		return EXIT_SUCCESS;
    }
}			\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

Pour ce faire il faut pouvoir naviguer dans les repertoires du système embarqué. On va donc faire recours aux fonctions \texttt{fopen()}, \texttt{fprintf()} et \texttt{fclose()} permettant respectivement, d'affecter à un pointeur de fichier (\texttt{FILE* fichier}) l'emplacement et le mode d'ouverture du fichier, écraser et écrire sur le fichier, et fermer le fichier suite aux opérations effectuées avec.

Les deux fichiers qui nous intéresse pour la manipulation des \texttt{GPIO}s sont \texttt{direction}, qui permet d'établir le sens (entrée/sortie - "in"/"out") de la \texttt{GPIO} à utiliser, et \texttt{value} sur lequel est stocké l'état de la \texttt{GPIO}.

On se permet aussi d'utiliser la fonction \texttt{sprintf()} pour affecter le chemin des fichiers \texttt{direction} et \texttt{value} de la \texttt{GPIO19} au chaine de charactères, \texttt{path\_d} et \texttt{path\_v}.

Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex3.o 1}\\
La LED de la \texttt{GPIO19} s'éteind.\\
\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex3.o 0}\\
La LED de la \texttt{GPIO19} s'allume.

\subsubsection{Exercise 2}

On veut comme dans l'exercise précédent pouvoir piloter le niveau logique d'une \texttt{GPIO}, cette fois-ci on utilisera un argument en plus pour désigner le numéro de la \texttt{GPIO} à utiliser.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char* argv[]) {
    if(argc != 3){
        printf("erreur %s, il faut 2 arguments", arcgv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        char path_d[100]; char path_v[100];
        int num = atoi(argv[1]);
		int val = atoi(argv[2]);

        sprintf(path_d, "/sys/class/gpio/gpio%d/direction", num);
        sprintf(path_v, "/sys/class/gpio/gpio%d/value", num);

        fichier = fopen(path_d, "w");
             fprintf(fichier, "out");
        fclose(fichier);

		fichier = fopen(path_v, "w");
             fprintf(fichier, "%d", val);
        fclose(fichier);

        return EXIT_SUCCESS;
    }
}		\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

Pour réaliser ceci on stocke le numéro de la \texttt{GPIO} dans la variable \texttt{num}, et son état dans la variable \texttt{val}.

Pour se diriger vers le bon emplacement de la \texttt{GPIO} on utilise dans la fonction \texttt{sprintf()}, l'argument \texttt{\%d} qui est un spécificateur de format permettant de remplacer celui-ci par la valeur de la variable \texttt{num} de type entier dans la chaine de charactères à affecter aux chemins \texttt{path\_d} et \texttt{path\_v}. On peut faire de même avec la fonction \texttt{fprintf()}.

Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex4.o 26 1}\\
La LED de la \texttt{GPIO26} s'éteind.\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex4.o 23 0}\\
La LED de la \texttt{GPIO23} s'allume.

\subsubsection{Exercise 3}

On veut établir un programme qui permet de faire clignoter la LED d'une \texttt{GPIO} dont le numéro sera passé en argument en ligne de commande jusqu'à l'interruption de l'exécution par la commande \texttt{CTRL+C}.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main (int argc, char* argv[]) {
    if(argc != 2){
        printf("erreur %s, il faut 1 argument", arcgv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        char path_d[100]; char path_v[100];
        int num = atoi(argv[1]);

        sprintf(path_d, "/sys/class/gpio/gpio%d/direction", num);
        sprintf(path_v, "/sys/class/gpio/gpio%d/value", num);

        fichier = fopen(path_d, "w");
             fprintf(fichier, "out");
        fclose(fichier);

        while(1){
            fichier = fopen(path_v, "w");
                fprintf(fichier, "1");
            fclose(fichier);
			sleep(1);

            fichier = fopen(path_v, "w");
                fprintf(fichier, "0");
            fclose(fichier);
			sleep(1);
        }

        return EXIT_SUCCESS;
    }
}	
				\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

On va donc utiliser une boucle \texttt{while(1)\{\ldots\}} de façon exécuter le programme en permanence, et on fera recours à la fonction \texttt{sleep} de la librairie \texttt{unistd.h} ainsi que les notions précédemment vues.

Dans notre boucle on va donc ouvrir le fichier \texttt{value} une première fois pour mettre l'état de la \texttt{GPIO} à $1$ et une deuxième fois pour la remettre à $0$, avec une pause de $1$ seconde entre chaque écriture.

Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex5.o 26}\\
La LED de la \texttt{GPIO26} clignote à une fréquence de $0.5\ H_z$

\subsubsection{Exercise 4}

En gardant le même fonctionnement que l'exercise précédent, on veut pouvoir modifier la fréquence de clignotement à partir d'un second argument passé en ligne de commande.

\newpage

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char* argv[]) {
    if(argc != 3){
        printf("erreur %s, il faut 2 arguments", arcgv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        char path_d[100]; char path_v[100];
	 	int num = atoi(argv[1]);

        float us_period = 1000000/(2*atoi(argv[2]));
    
        sprintf(path_d, "/sys/class/gpio/gpio%d/direction", num);
        sprintf(path_v, "/sys/class/gpio/gpio%d/value", num);

        fichier = fopen(path_d, "w");
             fprintf(fichier, "out");
        fclose(fichier);

        while(1){
            fichier = fopen(path_v, "w");
                fprintf(fichier, "1");
            fclose(fichier);
            usleep(us_period)

            fichier = fopen(path_v, "w");
                fprintf(fichier, "0");
            fclose(fichier);
			usleep(us_period)
        }

        return EXIT_SUCCESS;
    }
}				\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

En reprenant le code précédent on converti et stocke la période en $\mu s$ dans le flottant \texttt{us\_period}. Cette période est alors utilisé en conjonction avec la fonction \texttt{usleep()} pour établir la fréquence de clignotement demandée.

Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex6.o 23 5}\\
La LED de la \texttt{GPIO23} clignote à une fréquence de $5\ H_z$

\subsection{Pilotage GPIO en entrée}

\subsubsection{Exercise 1}

On cherche à écrire un programme permettant de lire l'état d'un bouton pressoir situé sur la \texttt{GPIO27} et d'afficher l'état sur la console.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char* argv[]) {
    if(argc != 1){
        printf("erreur %s, il faut pas d'argument", arcgv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        char path_d[100]; char path_v[100];

        char sval[1];
        int num = 27; int save = 1;

        sprintf(path_d, "/sys/class/gpio/gpio%d/direction", num);
        sprintf(path_v, "/sys/class/gpio/gpio%d/value", num);

        fichier = fopen(path_d, "w");
             fprintf(fichier, "in");
        fclose(fichier);

        while(1){
            fichier = fopen(path_v, "r+");
                fscanf(fichier, "%s", sval);
            fclose(fichier);
            state = atoi(sval);

            if(save != state){
                printf("\nSTATE : %d", state);
                save = state;
            }
        
        }
        return EXIT_SUCCESS;
    }
}		
				\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

Pour réaliser ceci on initialise la variable \texttt{num} à $27$, et on configure le sens de la \texttt{GPIO} en entrée("in").

Dans un boucle on va donc lire l'état de la \texttt{GPIO} en ouvrant le fichier sous le mode lecture (\texttt{r+}), et en utilisant la fonction \texttt{fscanf()} qui permet d'extraire les données dans le fichier. Notamment avec le specificateur \texttt{\%s} on relève la chaine de charactères qui est inscrite dans le fichier et on la stocke dans la chaine \texttt{sval[1]} placée en argument dans la fonction \texttt{fscanf()}. On converti ensuite cette chaine de charactères sous forme d'entier avec \texttt{state}.


On teste alors pour voir si la valeur relevé de l'état de la \texttt{GPIO} varie. Si c'est le cas alors on affiche cette valeur avec la fonction \texttt{printf()}, puis on sauvegarde cet état dans la variable \texttt{save} qui sera nouvellement comparé avec \texttt{state} pour savoir si l'état change. Sinon on continu de lire en boucle la valeur de l'état.
\newpage
Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex7.o}\\
\texttt{STATE : 1}\\
(Appui du bouton pressoir pendant 2 secondes)\\
\texttt{STATE : 0}\\
(Fin des 2 secondes)\\
\texttt{STATE : 1}

\subsubsection{Exercise 2}

On veut faire de même que l'exercise précédent mais en passant en argument le numéro de la \texttt{GPIO} à surveiller.

En considérant que le sens des \texttt{GPIO} à lire sont préétablies, on initialise \texttt{num} au numéro de la \texttt{GPIO} passé en argument. On modifie également la fonction \texttt{printf()} pour satisfaire la demande.

Le reste du code n'as pas besoin d'être modifié.

\newpage


\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char* argv[]) {
    if(argc != 2){
        printf("erreur %s, il faut 1 argument", arcgv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        char path_d[100]; char path_v[100];
		int num = atoi(argv[1]);

        char sval[1];
		int save = 1;

        sprintf(path_v, "/sys/class/gpio/gpio%d/value", num);

        while(1){
            fichier = fopen(path_v, "r+");
                fscanf(fichier, "%s", sval);
            fclose(fichier);
            state = atoi(sval);

            if(save != state){
				printf("\nSTATE GPIO&d : %d", num, state);
                save = state;
            }
        
        }
        return EXIT_SUCCESS;
    }
}		
				\end{lstlisting}
	\end{tabular}
	\caption{Code fonctionnel de l'exercise }
\end{figure}

Exemple d'exécution:\\
\texttt{pi@raspberry:\text{$\sim$}\$ \ ./ex8.o 19}\\
\texttt{STATE GPIO19 : 0}\\
(On allume la LED de la GPIO19)\\
\texttt{STATE GPIO19 : 1}\\
(On éteind la LED)\\
\texttt{STATE GPIO19 : 0}


\newpage
\section{Mise en fonctions}

\subsection{Direction d'un GPIO}

On cherche à réaliser une fonction qui aura le prototype : \texttt{void Ecrit\_DIR\_PORT(int num\_port, int dir)}\\
Pour $\texttt{dir}=1$ il faut que la \texttt{GPIO} soit mise en entrée, et pour $0$, en sortie.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h> 

void Ecrit_DIR_PORT(int num_port, int  dir){
    FILE* fichier; char path[100];

    sprintf(path, "/sys/class/gpio/gpio%d/direction", num_port);

    fichier = fopen(path, "w");
        if(dir == 1){
            fprintf(fichier, "in");
        } else {
            fprintf(fichier, "out");
        }
    fclose(fichier);
}				
				\end{lstlisting}
	\end{tabular}
	\caption{Code direction d'une \texttt{GPIO}}
\end{figure}

En utilisant les notions précédemment vues on écrit le code ci-dessous, avec lequel on ajoute un test pour savoir en fonction de \texttt{dir} s'il faut écrire \texttt{"in"} ou \texttt{"out"}.

\subsection{Écriture d'un GPIO}

On cherche à écrire une fonction qui aura le prototype : \texttt{void Ecrit\_ETAT\_PORT(int num\_port, int value)}

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>

void Ecrit_ETAT_PORT(int num_port, int value){
    FILE* fichier; char path[100];

    sprintf(path, "/sys/class/gpio/gpio%d/value", num_port);

    fichier = fopen(path, "w");
        fprintf(f,"%d", value);
    fclose(fichier);
}
				\end{lstlisting}
	\end{tabular}
	\caption{Code écriture d'une \texttt{GPIO} }
\end{figure}

\subsection{Lecture d'un GPIO}

On veut avoir une fonction qui permet de retourner l'état d'une \texttt{GPIO} avec le prototype suivant:\\ \texttt{void Lire\_ETAT\_PORT(int num\_port)}

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int Lire_ETAT_PORT(int num_port){
    FILE* fichier; char path[100]; char state[10]; int output;

    sprintf(path, "sys/class/gpio/gpio%d/value", num_port);
    
    fichier = fopen(path, "r+");
        fscanf(fichier, "%s", state);
    fclose(fichier);

    return output = atoi(state);
}
				\end{lstlisting}
	\end{tabular}
	\caption{Code lecture d'une \texttt{GPIO} }
\end{figure}

En utilisant les notions vues dans \textbf{1. Programmes de base}, on écrit le code ci-dessus.
\newpage
\subsection{Mise en bibliothèque}

On veut réunir toutes les fonctions définies précédemment dans une même librairie que l'on appellera \texttt{gpio.lib.c}. On écrit alors:

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

void Ecrit_ETAT_PORT(int num_port, int value){
    FILE* fichier; char path[100];

    sprintf(path, "/sys/class/gpio/gpio%d/value", num_port);

    fichier = fopen(path, "w");
        fprintf(f,"%d", value);
    fclose(fichier);
}

void Ecrit_DIR_PORT(int num_port, int  dir){
    FILE* fichier; char path[100];

    sprintf(path, "/sys/class/gpio/gpio%d/direction", num_port);

    fichier = fopen(path, "w");
        if(dir == 1){
            fprintf(fichier, "in");
        } else {
            fprintf(fichier, "out");
        }
    fclose(fichier);
}

int Lire_ETAT_PORT(int num_port){
    FILE* fichier; char path[100]; char state[10]; int output;

    sprintf(path, "sys/class/gpio/gpio%d/value", num_port);
    
    fichier = fopen(path, "r+");
        fscanf(fichier, "%s", state);
    fclose(fichier);

    return output = atoi(state);
}			
				\end{lstlisting}
	\end{tabular}
	\caption{Bibliothèque \texttt{gpio.lib.c}}
\end{figure}
\newpage
\section{Programmes}

\subsection{Chenillard à 4 LED}

On peut alors utiliser cette bibliothèque en rajoutant \texttt{\#include gpio.lib.c} au début de notre programme.\\
Pour faire un chenillard de fréquence modifiable on écrit le code suivant:

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

#include "gpio.lib.c"

int main(int argc, char* argv[]){
    if(argc != 2){
        printf("erreur %s, il faut 1 argument", arcgv[0]);
        return EXIT_FAILURE;
    } else {
        FILE* fichier;
        int ns_period = 1000000/atoi(argv[1]);

        int led[4] = {24,23,26,19};
        
        for(int i = 0; i < 4; i++){
            usleep(ns_period);
            Ecrit_ETAT_PORT(led[(i + 2) % 4], 1);
            Ecrit_ETAT_PORT(led[(i + 1) % 4], 1);
            Ecrit_ETAT_PORT(led[i], 0);
        }
    }
    return EXIT_SUCCESS;
}
				\end{lstlisting}
	\end{tabular}
	\caption{Code chenillard avec \texttt{gpio.lib.c}}
\end{figure}





















\end{document}
