\documentclass[11pt, openright]{book}

	% Cover Variables
	\newcommand{\ctitle}{en pont monophasé}
	\newcommand{\cautor}{Lucas Lescure - Eva Maturana}
	\newcommand{\ctoptitle}{Commande MLI d'un onduleur}

	% Header Variables
		\newcommand{\headRE}{\emph{\thepage}}
		\newcommand{\headLE}{\emph{\thesection. \rightmark}}
		\newcommand{\footRE}{}
		\newcommand{\footLE}{}

	% TOC Variables
		\newcommand{\toctitle}{Table of Content}
		\newcommand{\tocchapter}{Chapter}
		\newcommand{\toccount}{3}
  
	% Chapter Variables
		\newcommand{\chvar}{Chapter -}

\input{/root/.config/latex-utils/common/style.tex}
\input{/root/.config/latex-utils/common/math.tex}
\input{/root/.config/latex-utils/common/header.tex}
\input{/root/.config/latex-utils/common/toc.tex}

	% figure support
	\usepackage{import}
	\usepackage{xifthen}
	\pdfminorversion=7
	\usepackage{pdfpages}
	\usepackage{transparent}
	\newcommand{\incfig}[1]{%
			\def\svgwidth{\columnwidth}
			\import{./figures/}{#1.pdf_tex}
	}

	\pdfsuppresswarningpagegroup=1

\begin{document}
% Spacing
\input{/root/.config/latex-utils/common/begin.tex}

% Cover
\input{/root/.config/latex-utils/common/cover.tex}

\vspace{8.5cm}

\section*{Introduction}
\addcontentsline{toc}{subsection}{\hspace{2em}Introduction}

L'alimentation d'un moteur en courant alternative sinusoïdale est utile dans des application ou l'on souhaite un fonctionnement à vitesse constante. Ces sources sont typiquement fixées et donc pas adaptés pour des fonctionnement à vitesse variable. On préfèrera donc utiliser une commande MLI\footnote{Modulation en Largeur d'Impulsion}, permettant de controller la puissance fournie au moteur à partir d'une source continue de courant en faisant varier la largeur des impulsions.

Cependant lorsqu'une charge est alimenté par une commande MLI, il s'y présente des harmoniques sur le réseau qui nuisent la qualité de transfert de l'énergie, et interfèrent avec d'autres appareils sur le circuit. C'est pourquoi on cherchera donc comment supprimer les harmoniques multiples de rang $3$ et $5$ pour améliorer ce transfert d'énergie.


\newpage

\section{Objectifs du TP}

L'objectif de ce TP sera alors d'utiliser une structure en pont monophasé à IGBT\footnote{Insulated-Gate Bipolar Transistor} en commande MLI précalculée avec suppression des harmoniques $3$ et $5$.

\begin{figure}[ht!]
	\begin{tikzpicture}
		\node[overlay] at (-5,-3) {\includegraphics[width=0.6\textwidth]{./object/c1.png}};
		\draw[white] (-1.55,-1.4) -- (-5,-1.4);
		\draw[black!60, thin] (-6.55,-4.4) -- (-11,-4.4);
		\draw[black!60, thin] (-11,-4.4) -- (-11,-4.8) -- (-13,-4.8) -- (-13,-3.5) -- (-11,-3.5) -- (-11,-4.4);
		\node at(-12,-4.15) {\small Commande};
		\filldraw[fill=black] (-9.135,-4.4) circle (0.25mm);
		\node at (-5.75,-3.5) {\footnotesize$K_4$};
		\node at (-8.25,-3.5) {\footnotesize$K_3$};
		\node at (-5.75,-1.75) {\footnotesize$K_2$};
		\node at (-8.25,-1.75) {\footnotesize$K_1$};




	\end{tikzpicture}
	\caption{Structure en pont monophasé à IGBT}
\end{figure}

On rappelle aussi la forme d'onde de la tension de sortie qui est la suivante::

\begin{figure}[ht!]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				width=14cm, height=4cm,
				xmin= 0, xmax= 19,
				ymin= -3, ymax = 3,
				xticklabels=\empty,yticklabels={ ,$-E$, , $E$},
				xtick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18},
				axis lines = middle,
				grid=both
			]
			\draw[red,very thick] (0,2) -- (1.25,2) -- (1.25,-2) -- (1.75,-2) -- (1.75,2) -- (7.25,2) -- (7.25,-2) -- (7.75, -2) -- (7.75,2) -- (9,2) -- (9,-2) -- (10.25,-2) -- (10.25,2) -- (10.75,2) -- (10.75,-2) -- (16.25,-2) -- (16.25,2) -- (16.75,2) -- (16.75,-2) -- (18,-2);
			\draw[thick] (1.25,-2) -- (1.25,-2.3);
			\node at (1.05,-2.75) {\footnotesize$\alpha_1$};
			\draw[thick] (1.75,2) -- (1.75,2.3);
			\node at (1.95,2.5){\footnotesize$\alpha_2$};
			\draw[thick] (7.25,-2) -- (7.25,-2.3);
			\node at (6.75,-2.75){\footnotesize$\pi-\alpha_2$};
			\draw[thick] (7.75,2) -- (7.75,2.3);
			\node at (7.85,2.5){\footnotesize$\pi-\alpha_1$};
			\draw[thick] (9,-2) -- (9,-2.3);
			\node at (9,-2.75){\footnotesize$\pi$};
			\draw[thick] (10.25,2) -- (10.25,2.3);
			\node at (10.35,2.5) {\footnotesize$\pi+\alpha_1$};
			\draw[thick] (10.75,-2) -- (10.75,-2.3);
			\node at (11.25,-2.75) {\footnotesize$\pi+\alpha_2$};
			\draw[thick] (16.75,-2) -- (16.75,-2.3);
			\node at (16.75,-2.75) {\footnotesize$2\pi-\alpha_1$};
			\draw[thick] (16.25,2) -- (16.25,2.3);
			\node at (16.05,2.5) {\footnotesize$2\pi-\alpha_2$};
			\draw[dashed,thick] (4.5,3) -- (4.5,-3);
			\draw[dashed,thick] (13.5,3) -- (13.5,-3);
			\draw[dashed,thick] (18,3) -- (18,-3);
			\node at (18.55,-2.25) {\footnotesize$2\pi$};
		\end{axis}
		\node at(-0.45,2.5) {$v_s(t)$};
		\node at(12.5,1.5) {$\theta(rad)$};
	\end{tikzpicture}
	\caption{Forme d'onde $v_s(t)$}
	\label{Forme d'onde $v_s(t)$}
\end{figure}

On utilisera, comme ci-présent sur la forme d'onde, $2$ degrés de liberté $\alpha_1$ et $\alpha_2$ qui permettrons la suppression des harmoniques sur le signal de commande MLI.

\subsection{Analyse spectrale du signal MLI}

D'après la Figure 1.2. on a :
\begin{items}{-15pt}{-15pt}
	\item $v_s(t)=-v_s(t)$: Donc c'est une fonction impaire et n'admet que des sinus dans le développement en série de Fourier de $v_s(t)$.
	\item $v_s\left( t+\frac{T}{2} \right) =-v_s(t)$: Donc il y a symétrie de de glissement et il n'y aura que des termes impaires dans la série de Fourier.
\end{items}
Ceci nous permet alors de réduire l'intervalle d'étude de la série de Fourier à $\ds{\frac{T}{4}}$, soit:
\begin{eq}{-10pt}{0pt}
	\widehat{V}_{s_{2k+1}}&=\frac{4E}{\pi}\left[ \int\limits_{0}^{\alpha_1} \sin\big((2k+1)\theta\big) \  d \theta - \int\limits_{\alpha_1}^{\alpha_2} \sin\big((2k+1)\theta\big) \  d \theta + \int\limits_{\alpha_2}^{\frac{\pi}{2}} \sin\big((2k+1)\theta\big) \  d \theta   \right]\\
	\widehat{V}_{s_{2k+1}}&=\frac{4E}{(2k+1)\pi}\Big[1-2\cos\big((2k+1)\alpha_1\big)+2\cos\big((2k+1)\alpha_2\big)\Big]
\end{eq}

On peut alors écrire:\\
$\ds{v_s(t)=\widehat{V}_{s_{2k+1}}\cdot \sin\big((2k+1)\omega t\big)}$\\
$\ds{v_s(t)=\frac{4E}{(2k+1)\pi}\Big[1-2\cos\big((2k+1)\alpha_1\big)+2\cos\big((2k+1)\alpha_2\big)\Big]\cdot \sin\big((2k+1)\omega t\big)}$

Ainsi pour trouver les valeurs de $\alpha_1$ et $\alpha_2$  afin d'éliminer les harmoniques $3$ et $5$ il suffit de résoudre le système : \\
\centerline{$\ds{\begin{cases}
				\widehat{V}_{s_3}=0=1-2\cos(3\alpha_1) + 2\cos(3\alpha_2) \\
				\widehat{V}_{s_1}=0=1-2\cos(5\alpha_1)+2\cos(5\alpha_2)
			\end{cases} \eqi \begin{cases}
				\alpha_1=23.6^{\circ} \\
				\alpha_2=33.3^{\circ}
			\end{cases}}$}

\subsection{Stratégie de commande}

En ce référant encore à la Figure 1.2. on peut établir la commande de l'onduleur en pont qui sera:
\begin{items}{-15pt}{-15pt}
	\item Pour $v_s=E$ alors les interrupteurs $K_1$ et $K_4$ doivent êtres ouvert donc $v_c=10\ V$.
	\item Pour $v_s=-E$ alors les interrupteurs $K_2$ et $K_3$ doivent êtres ouvert donc $v_c=0\ V$ (ou $-10\ V$) suivante le type de pont utilisé.
\end{items}

La commande devra donc avoir la forme suivante:

\begin{figure}[ht!]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				width=14cm, height=4cm,
				xmin= 0, xmax= 19,
				ymin= -1, ymax = 5,
				xticklabels=\empty,yticklabels={ ,$0\ V$, , $10\ V$},
				xtick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18},
				axis lines = middle,
				grid=both
			]
			\draw[red,very thick] (0,4) -- (1.25,4) -- (1.25,0) -- (1.75,0) -- (1.75,4) -- (7.25,4) -- (7.25,0) -- (7.75, 0) -- (7.75,4) -- (9,4) -- (9,0) -- (10.25,0) -- (10.25,4) -- (10.75,4) -- (10.75,0) -- (16.25,0) -- (16.25,4) -- (16.75,4) -- (16.75,0) -- (18,0);
			\draw[thick] (1.25,0) -- (1.25,-0.3);
			\node at (1.05,-0.75) {\footnotesize$\alpha_1$};
			\draw[thick] (1.75,4) -- (1.75,4.3);
			\node at (1.95,4.5){\footnotesize$\alpha_2$};
			\draw[thick] (7.25,0) -- (7.25,-0.3);
			\node at (6.75,-0.75){\footnotesize$\pi-\alpha_2$};
			\draw[thick] (7.75,4) -- (7.75,4.3);
			\node at (7.85,4.5){\footnotesize$\pi-\alpha_1$};
			\draw[thick] (9,0) -- (9,-0.3);
			\node at (9,-0.75){\footnotesize$\pi$};
			\draw[thick] (10.25,4) -- (10.25,4.3);
			\node at (10.35,4.5) {\footnotesize$\pi+\alpha_1$};
			\draw[thick] (10.75,0) -- (10.75,-0.3);
			\node at (11.25,-0.75) {\footnotesize$\pi+\alpha_2$};
			\draw[thick] (16.75,0) -- (16.75,-0.3);
			\node at (16.75,-0.75) {\footnotesize$2\pi-\alpha_1$};
			\draw[thick] (16.25,4) -- (16.25,4.3);
			\node at (16.05,4.5) {\footnotesize$2\pi-\alpha_2$};
			\draw[dashed,thick] (4.5,5) -- (4.5,-1);
			\draw[dashed,thick] (13.5,5) -- (13.5,-1);
			\draw[dashed,thick] (17.5,5) -- (17.5,-1);
			\node at (18.55,-0.25) {\footnotesize$2\pi$};
		\end{axis}
		\node at(-0.45,2.5) {$v_c(t)$};
		\node at(12.5,0.75) {$\theta(rad)$};
	\end{tikzpicture}
	\caption{Forme d'onde de la commande $v_c(t)$}
	\label{Forme d'onde de la commande $v_c(t)$}
\end{figure}

Le schéma Synoptique de l'ensemble de la commande du convertisseur est la suivante:

\begin{figure}[ht]
	\begin{tikzpicture}
		\draw (0,0) -- (2,0) -- (2,1.5) -- (0,1.5) -- (0,0);
		\node at (1,0.75) {$\mu C$};
		\draw[-Latex] (2,1.2) -- (4,1.2);
		\draw[-Latex] (2,0.3) -- (4, 0.3);
		\draw (4,0) -- (6,0) -- (6,1.5) -- (4,1.5) -- (4,0);
		\node at (5,1) {\footnotesize Translateur};
		\node at (5,0.5) {\footnotesize de niveau};
		\draw[-Latex] (6,0.75) -- (8,0.75);
		\node at (9,1.2) {\footnotesize $v_c(t) = [0;\ 10V]$};
		\node at (8.5,0.75) {\footnotesize ou};
		\node at (9,0.3) {\footnotesize $v_c(t)=[-10V;\ 10V]$};

	\end{tikzpicture}
\end{figure}

\section{Pré-étude}

On peut découper le signal $v_s(t)$ comme une succession de signaux créneaux de période et durée à l'état haut variables. Cependant ces signaux ont chacun un $\alpha$ et $T$ différent comme on peut voir ci-dessous:

\begin{figure}[ht!]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				width=14cm, height=4cm,
				xmin= 0, xmax= 19,
				ymin= -3, ymax = 3,
				xticklabels=\empty,yticklabels={ ,$-E$, , $E$},
				xtick={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18},
				axis lines = middle,
				grid=both
			]
			\draw[red,very thick] (0,2) -- (1.25,2) -- (1.25,-2) -- (1.75,-2) -- (1.75,2) -- (7.25,2) -- (7.25,-2) -- (7.75, -2) -- (7.75,2) -- (9,2) -- (9,-2) -- (10.25,-2) -- (10.25,2) -- (10.75,2) -- (10.75,-2) -- (16.25,-2) -- (16.25,2) -- (16.75,2) -- (16.75,-2) -- (18,-2);
			\draw[dashed,thick] (4.5,3) -- (4.5,-3);
			\draw[dashed,thick] (13.5,3) -- (13.5,-3);
			\draw[dashed,thick] (18,3) -- (18,-3);
			\node at (18.55,-2.25) {\footnotesize$2\pi$};
			\filldraw[opacity=0.2, fill=green] (0,-3) -- (0,3) -- (1.75,3) -- (1.75,-3);
			\filldraw[opacity=0.2, fill=blue] (1.75,-3) -- (1.75,3) -- (7.75,3) -- (7.75,-3);
			\filldraw[opacity=0.2, fill=orange] (7.75,-3) -- (7.75,3) -- (10.25,3) -- (10.25,-3);
			\filldraw[opacity=0.2, fill=blue] (10.25,-3) -- (10.25,3) -- (16.25,3) -- (16.25,-3);
			\filldraw[opacity=0.2, fill=green] (16.25,-3) -- (16.25,3) -- (18,3) -- (18,-3);
		\end{axis}
		\node at(-0.45,2.5) {$v_s(t)$};
		\node at(12.5,1.5) {$\theta(rad)$};
	\end{tikzpicture}
	\caption{Forme d'onde $v_s(t)$ découpée en 5 créneaux}
\end{figure}

On peut relever ces signaux créneaux dans le tableau suivant avec $\Delta_k =\alpha'_k\cdot T_k$:
\begin{figure}[ht!]
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		$\Delta_k$ & $\alpha_1$ & $\pi-2\alpha_2$         & $\alpha_1$  & $\alpha_2-\alpha_1$     & $\alpha_2-\alpha_1$ \\
		\hline
		$T_k$      & $\alpha_2$ & $\pi-\alpha_2-\alpha_1$ & $2\alpha_2$ & $\pi-\alpha_1-\alpha_2$ & $\alpha_2$          \\
		\hline
	\end{tabular}
\end{figure}

Pour des raison de commodité on choisira une horloge pour le PWM qui aura 36000 période d'horloge pour une période du PWM, soit $36000\ T_{clock}= T_{total}$. Ainsi pour un réseau de période $20\ ms$ ($50\ H_z$), on a une période d'horloge à $T_{clock}=55.5\ ns$ et de fréquence $f_{clock}=1.8\ MH_z$

\section{Réalisation}

\subsection{Assemblage}

On va réaliser la commande de l'onduleur à l'aide du logiciel PSoC\footnote{Programmable System-on-Chip} en utilisant la carte microcontrôlleur CY8CKIT-042 PSoC 4 Pioneer Kit du fabricant Inifneon sur laquel nous avons un chip CY8C4225AXI-483.

Sur un nouveau projet vide, on instancie le \texttt{PWM(TCPPWM mode)} dans la fenêtre \texttt{TopDesign}. On configure alors le composant en cochant \texttt{On terminal count} puis on insère dans la case \texttt{Period} la valeur de $T_1=\alpha_1 = 2360$, et dans la case \texttt{Compare} la valeur du rapport cyclique $\Delta_1=\alpha_2 = 3330$.

On ajoute de la même façon le composant \texttt{Clock} (renomée "clock"), en lui configurant une fréquence $f_{clock}=1.8\ MH_z$, le composant \texttt{Interrupt}(renomée "isr") et un \texttt{Digital Output Pin}(renomé "PWM\_OUT"). On relie ensuite ces composants par un fil au PWM avec le composant \texttt{Clock} allant vers l'entrée \texttt{clock}, le composant \texttt{Interrupt} branché à la sortie \texttt{interrupt}, et le \texttt{Digital Output Pin} à la sortie \texttt{line}.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.4\textwidth]{./object/c2.png}
	\caption{Cablage des composant en \texttt{TopDesign} du projet}
\end{figure}

\subsection{Programmation}

On utilisera des variable globale dans le fichier \texttt{main.c} pour les durées à l'état haut et les périodes.Ainsi on fera intervenir dans des tableau \texttt{volatile}, \texttt{delta[5]} et \texttt{T[5]}, les valeurs précédemment trouvés lors de la pré-étude. Le qualificatif \texttt{volatile} est utilisé pour ne pas optimiser l'accès à la variable de façon à ce que le tableau puisse être utilisé par l'interruption même si une tache concurente l'utilisait.

On vas aussi définir des macros \texttt{alpha1},\texttt{alpha2} et \texttt{demip} pour remplacer la valeur de $\alpha_1$, $\alpha_2$ et celle de la demi période.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include "fonction.h"
			
#define alpha1 2360
#define alpha2 3330
#define demip 18000

volatile uint16_t delta[5]={alpha1, demip-2*alpha2, alpha1, alpha2-alpha1, alpha2-alpha1};
volatile uint16_t T[5]={alpha2, demip-alpha2-alpha1, 2*alpha1, demip-alpha1-alpha2, alpha2};
			\end{lstlisting}
	\end{tabular}
	\caption{Déclaration et initialisation des variables globales dans le \texttt{main.c}}
\end{figure}

Pour l'interruption on utilisera la fonction \texttt{isr\_StartEx()} qui prendra en paramètre le nom de notre interruption, ici \texttt{moninter}. On définira cette interruption dans le fichier \texttt{fonction.c} pour ceci on créé d'abord le fichier \texttt{fonction.h} dans lequel on utilise un API\footnote{Application Programming Interface} avec la libraire \texttt{project.h}. Grâce à celle ci on peut alors déclarer une interruption \texttt{moninter} de la façon suivante.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#ifndef INTERRUPT_HEADER
	#define INTERRUPT_HEADER
	#include "project.h"
	void startup(void);
	CY_ISR_PROTO(moninter);
#endif
			\end{lstlisting}
	\end{tabular}
	\caption{Contenu du fichier \texttt{fonction.h}}
\end{figure}

On en profite aussi pour déclarer la fonction \texttt{startup()} qui permettra d'initialiser les périphériques au démarrage.

On code alors dans le fichier \texttt{fonction.c} les définitions des fonctions \texttt{startup()} et \texttt{CY\_ISR(moninter)} qui sera déclenchée dans l'évènement d'une interruption. Dans le cas de l'interruption on affecte à une variable globale \texttt{source}, la source de l'interruption en veillant à plus tard effacer cette source pour éviter de rentrer dans une boucle infinie.

Le NVIC\footnote{Nested Vector Interrupt Controller} gère les demandes d'interruption et les envois au processeur. Quand une interruption est déclenchée un signal est envoyé au NVIC pour executer l'interruption correspondante définie dans notre programme, à la fin de l'interruption il faut remettre ce signal à 0 pour eviter que le NVIC ne réexécute l'interruption, c'est pourquoi on fait intervenir la fonction \texttt{PWM\_ClearInterrupt()} qui éfface la source d'interruption au NVIC.

Pour récupérer la source on utilise une variable globale \texttt{source} à laquelle on lui affecte la valeur de l'interruption avec la commande \texttt{GetInterruptSourceMasked()} pour qu'elle puisse ensuite être gérée par le NVIC dans la commande \texttt{PWM\_ClearInterrupt(source)}.

Dans l'interruption on affecte les valeurs de \texttt{Compare} et \texttt{Period} du MLI en utilisant les tableaux définis dans le fichier \texttt{main.c} donc il faut utiliser le mot clé \texttt{extern} pour que l'interruption puisse les accéder.

Cette affectation doit être réalisé à chaque coup d'interruption c'est à dire à chaque fois que la période d'un créneaux est finie. Pour passer d'un créneau à l'autre on définis une variable locale \texttt{i} à l'aide du mot clé \texttt{static} et qui permettra à la variable de réserver en emplacement mémoire qui ne sera pas désallouée quand le compilateur sort de l'interruption. On évite ainsi une erreur de segmentation car sans ce mot clé, la mémoire sera désallouée mais à la prochaine interruption on réutilise cette variable qui a déjà été définie mais qui n'as plus d'emplacement mémoire.

\begin{figure}[ht!]
	\centering
	\begin{tabular}{c}
		\begin{lstlisting}
#include "fonction.h"
extern uint16_t delta[5];
extern uint16_t T[5];

void startup () {
	Clock_Start();
	PWM_Start();
	isr_StartEx(moninter);
}

CY_ISR(moninter) {
	// Declaration de la variable source d'interruption
	uint32 source;
	//Affectation de la source d'interruption a la variable source
	source = GetInterruptSourceMasked();
	//Code a inserer
	static volatile uint8_t i=0;
	i = (i + 1) % 5;
	//Utilisation des fonctions PWM_WritePeriod() et PWM_WriteCompare()
	PWM_WriteCompare(delta[i]);
	PWM_WritePeriod(T[i]);
	//Effacage de la source d'interruption pour eviter la boucle infinie
	PWM_ClearInterrupt(source);
}
			\end{lstlisting}
	\end{tabular}
	\caption{Contenu du fichier \texttt{fonction.c}}
\end{figure}

\begin{figure}[ht!]
	\hspace{-3.5cm}
	\begin{tabular}{c}
		\begin{lstlisting}
int main() {
	CyGlobalIntEnable //Enable global interrupts

	//Place your initialisation/startup code here
	startup();

	for(;;) {
		//Place your application code here
	}
}
			\end{lstlisting}
	\end{tabular}
	\caption{Contenu du main dans le fichier \texttt{main.c}}
\end{figure}


\newpage
\subsection{Mise en Pratique}

On effectue le teste en utilisant un oscilloscope ayant le module FFT pour obtenir le spectre du signal de sortie du bloc MLI.
\begin{figure}[ht!]
	\begin{floatrow}
		\ffigbox{
			\includegraphics[width=0.5\textwidth]{./object/g1.jpeg}
			\caption{Spectre du signal avec harmoniques $3$ et $5$ supprimées}
		}

		\ffigbox{
			\includegraphics[width=0.5\textwidth]{./object/g2.jpeg}
			\caption{Chronogramme du signal de commande $v_c(t)$}
		}

	\end{floatrow}
\end{figure}



On obtient comme nous le voulions un spectre dont les harmoniques de rang 3 et 5 ont été supprimés et un signal de commmande conforme à ce qui à été trouvé lors de la pré-étude.




















\end{document}
