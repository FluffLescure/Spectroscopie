\documentclass[11pt, openright]{book}

    % Cover Variables
	\newcommand{\ctitle}{Base de Données}
        \newcommand{\cautor}{Lucas Lescure}
		\newcommand{\ctoptitle}{TP RCP30}

    % Header Variables
        \newcommand{\headRE}{\emph{\thepage}}
        \newcommand{\headLE}{\emph{\thesection. \rightmark}}
        \newcommand{\footRE}{}
        \newcommand{\footLE}{}

    % TOC Variables
        \newcommand{\toctitle}{Table of Content}
        \newcommand{\tocchapter}{Chapter}
        \newcommand{\toccount}{3}
  
    % Chapter Variables
        \newcommand{\chvar}{Chapter -}

\input{/root/.config/latex-utils/common/style.tex}
\input{/root/.config/latex-utils/common/math.tex}
\input{/root/.config/latex-utils/common/header.tex}
\input{/root/.config/latex-utils/common/toc.tex}

    % figure support
	\usepackage{import}
	\usepackage{xifthen}
	\pdfminorversion=7
	\usepackage{pdfpages}
	\usepackage{transparent}
	\newcommand{\incfig}[1]{%
            \def\svgwidth{\columnwidth}
            \import{./figures/}{#1.pdf_tex}
	}

	\usepackage{listings}

\definecolor{clr-background}{RGB}{255,255,255}
\definecolor{clr-text}{RGB}{0,0,0}
\definecolor{clr-string}{RGB}{200,80,21}
\definecolor{clr-namespace}{RGB}{0,0,0}
\definecolor{clr-preprocessor}{RGB}{128,128,128}
\definecolor{clr-keyword}{RGB}{0,0,255}
\definecolor{clr-type}{RGB}{0,0,200}
\definecolor{clr-variable}{RGB}{0,0,0}
\definecolor{clr-constant}{RGB}{0,100,138} % macro color
\definecolor{clr-comment}{RGB}{0,128,0}

\lstset{
        language=C++,
        backgroundcolor=\color{clr-background},
        basicstyle=\color{clr-text}\scriptsize, % any text
        stringstyle=\color{clr-string},
        identifierstyle=\color{clr-variable}, % just about anything that isn't a directive, comment, string or known type
        commentstyle=\color{clr-comment},
        % listings doesn't differentiate between types and keywords (e.g. int vs return)
        % use the user types color
        keywordstyle=\color{clr-type},
        keywordstyle={[2]\color{clr-constant}}, % you'll need to define these or use a custom language
        tabsize=4
}

	\pdfsuppresswarningpagegroup=1

\begin{document}
% Spacing
\input{/root/.config/latex-utils/common/begin.tex}

% Cover
\input{/root/.config/latex-utils/common/cover.tex}

\newpage

\section{D'emarrage de PostgreSQL}

On récupère sous Moodle le kit \texttt{KitEtuBddPgSQL.zip} que l'on procède par extraire, ainsi que tout les fichiers \texttt{.zip} contenu à l'intérieur. \\
En ouvrant alors une fenêtre de commande on se redirige à l'emplacement de ce fichier et on renomme le répertoire \texttt{pgsql1} à \texttt{PostgreSQL\_12.4\_Portable}. Ensuite on commence par créer un nouveau \textbf{cluster} de base de donnés en modifiant le fichier \texttt{Make Cluster.bat} avec la commande suivante :
\begin{lstlisting}
		"%CD%\bin\initdb" -D "%RutaCluster%" -U postgres -W --encoding=UTF8
	\end{lstlisting}

On peut alors lancer le script dans la ligne de commande avec \texttt{"Make Cluster.bat"}. L'exécution du fichier demande un nom au répertoire du nouveau cluster. On le nommera \texttt{data2}. Une fois crée entrer le mot de passe de l'administrateur de la base de donnée.

On commence désormais par modifier les fichiers \texttt{PostgreSQL-Start.bat} \texttt{PostgreSQL-Restart.bat} \texttt{PostgreSQL-Stop.bat} en plaçant chacun des \texttt{data} en \texttt{data2}, exemple:
\begin{lstlisting}
		"%CD\bin\pg_ctl.exe%" start -D "%CD%\data2"
	\end{lstlisting}

Dans la command line on peut donc commencer le serveur SQL en tapant la commande \texttt{"PostgreSQL-Start.bat"}. Une fois initialisé on peut la modifier en utilisant le logiciel \texttt{pgAdmin}

Dans le client \texttt{pgAdmin} on crée une nouvelle connexion au serveur de façon suivante:
\begin{items}{-15pt}{-15pt}
	\item nom: PostgreSQL\_12.4\_Portable
	\item hôte: localhost
	\item port: 5432
	\item base maintenance: postgres
	\item username: postgres
	\item password: <Mot de passe>
\end{items}
Après ceci on ouvre le \texttt{Query Tool} et on crée notre serveur à partir de la commande :
\begin{lstlisting}[language=SQL]
		CREATE DATABASE plateformes_multimedia OWNER postgres ;
	\end{lstlisting}

\section{Construction de la Base de données}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.95\textwidth]{./object/g1.png}
	\caption{Modèle relationnel à réaliser}
\end{figure}

\subsection{Phase 1: importation du dump dans la base de données}

Une partie est déjà crée dans le fichier \texttt{dump\_plateformes\_multimedia.sql}. C'est ce que l'on appelle un \texttt{dump}, et contient l'ensemble des requêtes SQL qui ont permis de créer et remplir une partie de la base.

On procède par ouvrir ce fichier en étant sur le \texttt{Query Tool} puis on execute (avec \texttt{F5}) . À la suite on supprime tout le code et on tape la commande:
\begin{lstlisting}
				set search_path = 'public' ;
			\end{lstlisting}

\subsection{Phase 2 : création des tables \texttt{type\_plateforme} et \texttt{contenu\_genre}}

Après l'analyse des elements on remarque qu'il manque la table \texttt{type\_plateforme} et la table tampon \texttt{contenu\_genre}. On va donc devoir les créer tout seul en respectant les contraintes associés.

Concernant la table \texttt{type\_plateforme} il faudra, une fois crée, executer le script \texttt{trigger\_insert\_update\_type\_plateforme.sql}. On devra ensuite ajouter l'attribut \texttt{id\_type\_plateforme} dans la table \texttt{plateforme} et poser la contrainte de clé étrangère vers l'\texttt{id} de \texttt{type\_plateforme}.

Pour ce qui concerne le dump, on peut ce référer à la phase 1 pour se faire.

Pour la création de la table on peut utiliser la commande suivante :
\begin{lstlisting}[language=SQL]
				CREATE TABLE type_plateforme(ID serial 	PRIMARY KEY, 
							nom_libre text UNIQUE NOT NULL,
							nom_maj text UNIQUE NOT NULL);
			\end{lstlisting}
Pour ensuite configurer la clé étrangère on doit d'abord crée l'attribut auquel appartiendra la clé étrangère pour ceci on peut ce référer au code :
\begin{lstlisting}[language=SQL]
				ALTER TABLE plateforme ADD COLUMN id_type_plateforme int;
			\end{lstlisting}
Ensuite on configure la clé étrangère avec la commande :
\begin{lstlisting}[language=SQL]
				ALTER TABLE plateforme ADD CONSTRAINT fk_id_type_plateforme
				FOREIGN KEY (id_type_plateforme) REFERENCES type_plateforme(ID)
				ON DELETE SET NULL
				ON UPDATE CASCADE;
			\end{lstlisting}
Dans lequel on référence la clé étrangère directement au tableau associé \texttt{type\_plateforme} comme il est décrit dans le modèle relationnel.

On répète ceci pour la table \texttt{contenu}.

On réalise en utilisant donc ce principe de clé la table tampon suivante:
\begin{lstlisting}[language=SQL]
				CREATE TABLE contenu_genre ()
				ALTER TABLE contenu_genre ADD COLUMN id_contenu int;
				ALTER TABLE contenu_genre ADD COLUMN id_genre int;

				ALTER TABLE contenu_genre ADD CONSTRAINT pk_contenu
				PRIMARY KEY (id_contenu, id_genre);

				ALTER TABLE contenu_genre ADD CONSTRAINT fk_id_contenu
				FOREIGN KEY (id_contenu) REFERENCES contenu(ID)
				ON DELETE CASCADE
				ON UPDATE CASCADE;

				ALTER TABLE contenu_genre ADD CONSTRAINT fk_id_genre
				FOREIGN KEY (id_genre) REFERENCES genre(ID)
				ON DELETE CASCADE
				ON UPDATE CASCADE;
			\end{lstlisting}

\subsection{Phase 3: Insertion et mise à jour de donnés}

Dans cette phase on veux pouvoir faire des requête d'insertion (INSERT INTO), de suppression(DELETE) et de mise à jour (UPDATE). \\
Avec un fichier excel, \texttt{data.xlsx} on se propose de transférer ces donnés dans notre base de donné.
Pour la copie directe de donnés, il faut sauvegarder notre excel sous format \texttt{.csv} et veillé the le codage soit en \texttt{UTF-8}. Ensuite on peut alors copier ses donnés en suivant la commande :
\begin{lstlisting}[language=SQL]
				COPY type_plateforme(ID,nom_libre)
				FROM 'D:\Users\lucas\Downloads\KitEtuBddPgSQL\KitEtuBddPgSQL' CSV
				DELIMITER ',';
			\end{lstlisting}







\end{document}
